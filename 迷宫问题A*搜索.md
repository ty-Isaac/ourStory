---
title: A*算法

date: 2017-04-19 19:23:57

categories: 编程

tags: [A*算法,人工智能,迷宫问题,八数码问题]
---

# 启发式搜索

# A*搜索算法

> http://www.cnblogs.com/mingjiatang/p/5967681.html

## A*搜索算法简介

A*搜索算法是一种启发式算法。即在盲目搜索的过程加入一个启发函数，对于当前结点搜索完毕后，使用启发函数对每一个子结点的状态计算代价，选择代价最小的节点作为下一步的搜索节点。通过不断求最优，就可以找到最优解。

DFS，BFS都是属于盲目搜索，选择子结点是根据固定顺序选择，在某些情况下求解会产生大量的冗余步骤。而A*搜索算法会是根据一个启发函数值来判别从哪一个节点继续进行搜索。启发函数的表达形式为：

​							$f(n)=g(n)+h(n)$ 

其中$f(n)$是每个节点的估值或者代价值。$g(n)$表示从起点到搜索点的代价，$h(n)$代表搜索点到目标点的代价，$h(n)$会直接影响到A*算法的效率。

一种具有$f(n)=g(n)+h(n)$的启发式算法能成为A*算法的充分条件是：

1. 搜索树上存在从起点到终点的最优路径
2. 问题域有限
3. 所有子结点的搜索代价值都大于0
4. $h(n)\leq h*(n)$

## A*搜索算法描述

A*算法的流程如下：

A*算法需要两个额外的存储空间，OPEN表和CLOSE表。

1. 初始化OPEN表和CLOSE表，将开始节点（开始节点的Hvalue和Gvalue都视为0）放入OPEN表中
2. 重复下面步骤(循环)
   1. 在开始列表中查找具有最小Fvalue的节点作为当前节点
   2. 把当前节点从OPEN表中删除，并加入到CLOSED表中
   3. 对当前节点的每一个相邻节点依次执行以下步骤：
      1. 如果相邻节点不可通行或者该节点已经在CLOSE表中，则什么操作也不执行
      2. 如果该相邻节点不在OPEN表中，则将该节点添加到OEPN表中，并<u>将该相邻节点的父节点设置为当前节点</u>，同时计算保存相邻节点的Fvalue
      3. 如果该相邻节点在OPEN表中，则判断若经由当前节点到达该相邻节点的Fvalue是否小雨原来保存的Fvalue，若小于则将该相邻节点的父节点设置为当前节点，并重新计算该相邻节点的Fvalue
      4. 若当终点节点被加入到OPEN表作为待检验节点时，表示路径已经找到，此时应终止循环；若当OPEN表为空，表示没有从开始节点到终点节点的路径，此时循环结束
3. 循环终止后，从终点节点开始沿父节点往前遍历，从后到前输出搜索路径。

其中，设置相邻节点的父节点为当前节点为了记录从起始节点到终止节点的路径，方便搜索路径后对路径进行输出。

## A*算法对于八数码问题

### 启发式A*算法

open表：存放所有待扩展的节点

closed表：存放所有已扩展的节点

spring表：存放所有待处理的节点状态

```java
List<State> open = new ArrayList<>();  //open表
List<State> closed = new ArrayList<>();     //close表
List<State> spring = new ArrayList<>();     //spring表
int start[]={1,2,4,3,5,6,7,8,0};            //初始状态数组
int goal[] = {1,2,3,8,0,4,7,6,5};           //目标状态数组
State startState = new State();         //初始状态
State goalState = new State();          //目标状态
```

### 算法步骤

1. 检查是否有解（逆序数）

   将9宫格横向展开，左边的数大于右边的数的组数称为逆序数。横向平移逆序数增量为0、2或-2。纵向平移逆序数增长为0、4或-4。因此，初态和目标态的逆序数和应该是偶数。（即初态逆序奇数、末态逆序也为奇数和为偶数）若不是偶数代表此八数码无解。

2. 初始化open表（存放待扩展的节点）、close表（存放已扩展的节点）、spring表（存放答案）、初始状态、目标状态。

3. 计算初始状态的g、h、f值后，将初始状态加入到open表中

4. 检查问题是否有解

5. 循环()

   1. 在open表中取出一个状态getOfOpen，判断是否是目标状态。是目标状态则结束

   2. 将状态getOfOpen加入closed表

   3. 将状态getOfOpen产生后继节点

      1. 获取0的位置，将0进行四个方向移动的尝试，可以则移动。
      2. 判断该移动方向得到的结果是否与其前驱节点相似。
      3. 不相似创建新的状态点加入到spring中。

   4. 检查spring表中所有的节点(state)

      如果在open表中有相同节点(stateInOpen)。如果state的g值<stateInOpen的g值，则改变open表中(stateInOpen)的参数，并将open表中的状态按gvalue重排。并从spring表删除该节点。

      如果在closed表中有相同节点(stateInClosed)，state的g值<stateInClosed的g值，则改变closed表中(stateInClosed)的参数，将stateInClosed加入open表并排序。并从spring表删除该节点

      否则将state加入open表，并从spring表中删除该节点

### 算法空间表示

状态用一维数组表示，每个节点状态存以一个State对象存储。包括存储Fvalue，Gvalue，Hvalue。对于九宫格按行展开存入数组，用0表示移动位置（空格）。

## A*算法对于迷宫问题

采用A*算法对迷宫路径求解中，$g(n)$和$h(n)$都采用==曼哈顿距离==，曼哈顿距离代表两个点在标准坐标上的绝对轴距总和。
$$
d(i,j)=|x_1-x_2|+|y_1-y_2|
$$
即每次获取的当前通道块，都会对其到入口通道块和出口通道开的曼哈顿距离进行计算。求算当前通道块的Fvalue进行保存。该函数满足启发式算法的充分条件1、2、3、4。

对于迷宫问题需要将A*算法进行更改，其中2-3-1，如果相邻节点不可通行或者该节点已经在close表或open表中，则什么也不执行；2-3-2，如果该节点不在open表和close表中，则将该节点添加到open表中，并将该节点的父节点设置为当前节点，同时计算保存相邻节点的$Fvalue$。

在迷宫求解中使用A*搜索算法不需要更新OPEN表中已存在节点的Fvalue，因为每个节点的位置都是确定的，所以曼哈顿九黎就是固定的。如果是带权值的网路求解最短路径，那么就需要去更新open表中节点的$Fvalue$，如$Dijkstra$算法。



