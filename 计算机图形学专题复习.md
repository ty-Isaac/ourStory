---
title: 计算机图形学复习要点
date: 2017年06月24日11:06:51
categories: review
tags: [复习,计算机图形学]
---



# 计算机图形学复习要点

## 第一章 计算机图形学概述

#### 计算机图形的概念与研究的内容

1. 图形的概念

   - 广义的图形概念 

     凡是能够在人的视觉系统中形成视觉印象的客观对象都称为图形。如：

     - 自然景物
     - 照片和图片
     - 工程图、设计图和方框图
     - 人工美术绘画、雕塑品
     - 用数学方法描述的图形（包括几何图形、代数方程、分析表达式或列表所确定的图形

   - 计算机图形学中的图形概念

     是指由点、线、面、体等几何要素和明暗、灰度（亮度）、色彩等非几何要素构成的，从现实世界中抽象出来的带有灰度、色彩及形状的图或形。

2. 计算机图形学的研究内容

   用计算机生成景物的数字模型，并将它显示在计算机屏幕上，或者绘制在纸张或胶片上。它是**研究如何在计算机环境下生成、处理和显示图形的一门学科**。

   主要研究对象：

   - **景物的几何建模**方法(modeling)对模型的处理方法
   - **几何模型的绘制技术**(rendering)
   - 图形输**入和控制的人机交互界面**(userinterface)。

#### 图形学发展史

#### 计算机图形的应用

1. 计算机**辅助设计与制造**
2. 地理信息系统
3. 科学计算可视化
4. 计算机动画和艺术
5. 计算机模拟和仿真
6. 虚拟现实

##  第二章 计算机绘图初步认识

#### 如何在计算机上绘图

1. 计算机绘图的一般方法

2. 一般图形的显示流程

   分为三个阶段：图形的数字化，图形操作，图形输出

   模型坐标系（局部坐标系）：在图形处理过程中每个图形都有自己的坐标系

   世界坐标系：一个图形场景往往由多个图组成，为了描述它们之间的空间关系，要把它们置于统一的坐标系中

   设备坐标系：要输出经过处理后的数字化图形，需要在输出设备上建立一个坐标系

   ![图片显示流程](http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B.png)


OpenGL图形软件包简介

## 第三章 计算机图形系统及硬件

#### 概述

1. 计算机系统中的图形设备
2. 图形的输入输出处理流程
3. 图形工作站与PC机

#### 计算机系统中的图形设备

计算机图形系统用来生成、处理和显示图形，通常由**中央处理机**、**图形输出设备**和**图形输入设备**构成。

计算功能、存储功能、输入功能、输入功能交互功能

#### 图形显示原理

1. CRT显示器
   - CRT显示原理

   - 彩色CRT的显示原理

   - 光栅扫描式的图形显示器

     - **是画点设备，可看成一个点阵单元发生器，并可控制每个点阵单元的亮度**。
     - 发出的电于束的偏转方式是固定的，**自上而下，从左到右扫描在荧光屏上形成光栅形状**。
     - 图形是通过电子束扫描到光栅上的图形象素点时呈现的亮度或颜色与光栅背景的亮度或颜色不同而衬托出的，可形成多级灰度或颜色的实面积自然图像。
     - 由于图像是由像素阵列组成，**显示一幅图像所需要的时间等于显示整个光栅所需的时间，而与图像的复杂程度无关**。

2. 随机扫描的图形显示器

   随机扫描显示器和存储式管理的显示器都是画线设备，在屏幕上显示一条直线是从屏幕上的一个可编址点直接画到另一个可编址的点

3. 液晶显示器

   液晶，即液态晶体。是具有线状结晶结构的分子，可像液体一样流动。如果把它加热会呈现透明的液体状态，冷却成固体状态。

4. 等离子显示器

   由密封在玻璃膜夹层中的晶格矩阵（光栅）组成，每个晶格充满低压气体。在高压作用下，气体会电离解，即电子从原子中游离出来。


#### 图形绘制设备

输出设备：喷墨绘图机、激光打印机、笔试绘图机

输入设备：鼠标、键盘、光笔、数字化仪、触摸板、图形扫描仪、手写输入板

## 第四章 基本光栅图形算法

#### 直线生成算法

理想的直线是没有宽度的，是由无数个点构成的集合 

在光栅的有限像素点阵中，确定最佳逼近于该直线的一组像素，用这些像素表示该直线。

1. DDA

   ```C
   void dda(int x1, int y1, int x2, int y2){
     int k,i;
     //k 即起点和中的横纵坐标距离较大者的距离
     //即 将距离大者分为k段
     float x,y,dx,dy;
     k=abs(x2-x1);
     if(abs(y2-y1)>k) k=abs(y2-y1);
     dx=float(x2-x1)/k;  //增量，每次横坐标增量
     dy=float(y2-y1)/k;  //每次纵坐标增量 
     //有一个的增量<1，另一个增量=1
     x=float(x1);
     y=float(y1);
     for(i=0;i<k;i++){
       gl_Point(int(x+0.5),int(y+0.5));	//取整
       x=x+dx;
       y=y+dy;
     }
   }
   ```

   该算法计算量大，产生一个象素需要两次加法，两次取整。还需要除法，增加硬件难度。

2. 正负法

   假设 $P=(x,y)$ 是直线上的一点，与P最近的像素为$(x_i,y_i)$(  表示)，那么下一个与直线最近的像素只能是正右方的$P_B$或右上方的$P_T$两者之一。以M表示$P_B$和$P_T$的中点，Q是直线与垂线 $x=x_i+1$的交点。

   显然，若M在Q的下方，则$P_T$离直线近，应取 为下一个像素，否则应取$P_B$

3. Bresenham算法

   axc

#### 圆弧生成算法

1. 正负法
2. Bresenham算法
3. 圆弧的离散生成

#### 多边形填充（P51）

1. 多边形表示方法

   - **顶点表示**：是用**多边形的顶点的序列来描述多边形**，该表示**几何意义强**、占内存少，但它不能直观地说明哪些像素在多边形内。
   - **点阵表示**：是用位于**多边形内的象素的集合来刻划多边形**，该方法虽然没有多边形的几何信息，是**面着色所需要的图像表示形式**。
   - **多边形填充就是把多边形的顶点表示转换为点阵表示**。即从多边形的给定边界出发，求出位于其内部的各个像素，并将帧缓冲器内的各个对应元素设置相应的灰度或颜色。

2. 多边形填充的扫描线算法

   扫描线算法是效率较高的多边形填充算法，充分利用了**相邻象素之间的连续性**，避免反复求交。

   - 区域的连续性

     - 梯形的两底边分别在$y= y_{i_k} $和$y=y_{i_{k+1}}$ 两条扫描线上，腰在多边形P的边上或在显示屏幕的边界上。
     - 梯形可分为两类：一类位于多边形P的内部；另一类在多边形P的外部。
     - 两类梯形在长方形区域$\{ y_{i_k} ，y_{i_{k+1}}\}$内相间的排列。

   - 扫描线的连续性

     - 交点个数 $l$ 是偶数
     - 扫描线上的一些点位于多边形P内，其余区间都在P外。
     - 在该扫描线上，只有区段$(x_{ei_k}，x_{ei_{k+1}})$其中 $k=1,3,5,…,l–1$位于多边形P内

   - 边的连续性

     - $d=e-1$
     - 两序列元素的个数相等
     - 点$( x_{ei_r},e)$与$(x_{di_r},d)$位于多边形P的同一边上，即 $x_{ei_r} = x_{di_r}+\frac {1}{m_{i_r}}$

   - 奇点处理

     - 为了使交点个数保持为偶数，**规定当奇点是P的极值点时，该点按两个交点计算**；否则按一个交点计算
     - 若 $P_i$ 是非极值点，则将$(P_{i-1},P_i),(P_i,P_{i+1})$  两边中位于扫描线$y=y_i$**方的那条边在$P_i$点处截去一单位长** 

   - 扫描线算法的数据结构域实现步骤

     - 边 y. 筒ET

       按边下端点的纵坐标$y$对非水平边进行分类的指针数组。下端点的纵坐标 $y$ 等于 $i$ 的边归入第$i$类。同一类中按$x$值进行排序。

       生成方式：从低端向上扫描

     - 边的活化链表AEL

       由与当前扫描线相交的所有多边形组成，记录多边形边沿扫描线的交点序列

     - 四个域组成

       | $y_{max}$ | $x$                          | $\Delta x$ | $next$    |
       | --------- | ---------------------------- | ---------- | --------- |
       | 边的上端点y坐标  | 边y筒中表示下端点x坐标；AEL中边与扫描线的交点x坐标 | 边斜率的倒数     | 指向下一条边的指针 |

     - 算法步骤

       - （AEL初始化）将边的活化链表AEL置空
       - （y初始化）取扫描线纵坐标y的初始值为**ET中**非空元素的最小序号
       - 按从下到上的顺序对纵坐标值为y的扫描线（当前扫描线）执行下列步骤直到边的活化链表为空
         - 如边ET中的第y类元素非空，则从ET中将第y类的所有边取出，按照x值（x值相等时，按$\Delta x$值）递增方向插入到活化链表AEL中
         - 若AEL非空，将AEL中的边亮亮依次配对，填充所有线段对$（x_1,y）$和$（x_2,y）$，$（x_3,y）$和$（x_4,y）$，……
         - 将AEL中满足y=y_max的边删去
         - 将AEL剩下的每条边的X域累加$\Delta x$ ，即 $x = x + \Delta x$
         - 将当前扫描线的纵坐标值y累加1，即$y=y+1$

3. 边缘填充算法

   多边形填充的扫描线算法中，建立ET筒和AEL活化链表时**需要对多边形的边进行排序**，该算法采用**对图像进行逐位求反**的方法可以免去对边排序的工作量。

   - 算法实现：对多边形P的每一非水平边$P_iP_{i+1}$上的各象素做向右求反运算即可。
   - 优势：数据结构和程序简单，对单值图像比较有用
   - 劣势：需要对帧缓冲器中的**大批元素反复赋值**，速度不比扫描线快。



4. 边界标志

   首先用特殊颜色在帧缓冲器中将多边形边界（水平边的部分边界除外）勾画出来，然后再把位于多边形内的各个象素着色。

   - 算法实现：
     - 步骤1：以值为boundary-color 的特殊颜色勾画多边形P的边界。设多边形顶点为$P_i= (x_i, y_i) $$0≤i≤n， x_i, y_i$均为整数；置 $P_{n+1}=P_0$ 每一条扫描线上着上这种特殊颜色的点的个数必定是偶数(包括零)
     - 步骤2：设**interior_point**是一布尔变量。对每一条扫描线从左到右进行搜索，如果当前是像素位于多边形P内，则interior_point=true，需要填上值为polygon_color的颜色；否则该像素在多边形P外，需要填上值为background_color的颜色

   **避免了对帧缓冲器中的大量元素的多次赋值**，但需要逐条扫描线对帧缓冲器中的元素进行搜索和比较。

#### 区域填充

1. 区域概念

   指先将区域内的**一点**(常称种子点)赋予给定颜色，然后将这种颜色扩展到整个区域内的过程。

   区域是指已经表示成点阵形式的象素集合。光栅图形中，区域可采用内点表示和边界表示。

   - 内点表示

     把位于给定**区域内的所有象素**一一列举出来的方法

   - 边界表示法

     把位于给定区域的**边界上的象素**一一列举出来的方法.它将区域边界上的象素都着上同一种颜色(常称为边界色)。

   - 区域的连通性
     - 四连通区域

       取区域内任意两点，在该区域内若从其中一点出发通过**上、下、左、右**四种运动可到达另一点。

     - 八连通区域

       取区域内任意两点，若从其中任一点出发，在该区域内通过沿水平方向、垂直方向和对角线方向的八种运动可到达另一点。

2. 简单的种子填充算法

   给定区域G一种子点（x,y），首先**判断该点是否是区域内的一点**，**是则将该点填充为新的颜色**，然后将该点周围的四个点（四连通）或八个点（八连通）作为新的种子点进行相同处理，通过这种扩散完成对整个区域填充。

3. 扫描线种子填充算法

   区域填充的递归算法程序简单、表达清楚。但是由于多层递归，需要反复进行费时、费内存的堆栈操作，一般用于细小的区域进行填充。

   **扫描线种子算法，从给定的种子点开始，填充当前扫描线上种子点所在的区间，然后确定与这一区间相邻的上下两条扫面线上需要填充的区间**，从这些区间上各取一个种子点并以此把它们保存起来，作为下次填充的种子点，反复进行直到所保存的各区间都填充完毕

   算法步骤：

   1. 将算法设置的堆栈置为空，将给定种子点（x,y）压入堆栈
   2. 如果堆栈为空，算法结束；否则取栈顶元素（x,y）作为种子点
   3. 从种子点开始，沿纵坐标为y的当前扫描线**向左右两个方向**逐个用新的颜色值进行填充，直到边界为止。设区间的横纵坐标分别为$x_{left}$和$x_{right}$。
   4. 在与当前扫描线相邻的上下两条扫描线上，以区间$[x_{left},x_{right}]$为搜索范围，求出需要填充的各小区间，把各小区间中**最右边的点**作为种子点压入堆栈，移向2

   流程的图


#### 光栅图形的反走样算法（不考）

1. 光栅图形的走样现象

   图形的边界一般都呈阶梯形

   图形的细节失真、狭小图形遗失图形的细节失真、狭小图形遗失

2. 提高分辨率的反走样算法

   采用硬件：采用高分辨率的光栅图形显示器，花费的代价大。

   采用软件：花费的代价小，也容易实现。 （高分辨率计算，低分辨率显示）

   高分辨率计算：将低分辨的图形显示象素划分为许多子象素，如2×2划分，3×3划分等，然后按通常的算法计算出各个子象素的颜色值或灰度值。

   低分辨率显示：将一象素内的各个子象素的颜色值或灰度值的平均值作为该象素的颜色值或灰度值。求平均值时可取算术平均，也可取加权平均。

3. 线段反走样算法

   把线段看作是有宽度的狭长的矩形如图4.28

   线段具有一定的面积，当线段通过某象素时，可以求出两者面积的交

   根据每一象素与线段相交部分的面积值决定该象素的颜色值或灰度值

4. 多边形反走样算法

## 第五章 变换和裁剪

#### 变换的数学基础

#### 几何变换

##### 坐标系

世界坐标系（world coordinate）:一个图形场景往往由多个对象组成，为了描述它们之间的空间关系，需要把它们置于一个统一的坐标系中，该坐标系称为**世界坐标系**。

模型坐标系（modeling coordinate）或局部坐标系（local coordinate）：当构造单个对象的数字模型时，为了方便可以将其置于一个特定的坐标系下，即**模型坐标系**或**局部坐标系**。

设备坐标系（device coordinate）：图形输出时，则应在输出设备上建立一个坐标系，这个坐标系称为**设备坐标系**。设备坐标系依据设备的种类有不同的形式，如二维的屏幕坐标系，描述机械手运动轨迹的三维坐标系。

标准化设备坐标系（normalized device coordinate）：有些图形系统，对设备坐标系进行了规范化，将坐标范围限定在区间{x,y,z | 0≤x≤1, 0≤y≤1, 0≤z≤1}内，称为**标准化设备坐标系**。

每一图形的模型都有自己的坐标系，此坐标系为模型坐标系或局部坐标系。图形场景由多个图形组成，它们被放置在一个统一的坐标系中，称为世界坐标系

1. 基本变换
   - 平移变换
   - 缩放变换
     - 原点为相似中心
     - 定义其他点为相似中心
     - 为使缩放后的图形仍在原来位置附近，定义相似中心$(x_p,y_p,z_p)$ ，把整个图形沿x,
       y和z方向平移$-x_p,-y_p$和$-z_p$,使相似中心移到坐标原点；然后对每一点作缩放变换；最 后再沿x, y和z方向平移$x_p,y_p$和$z_p$,把经过放缩的图形移回原处，这样就以$(x_p,y_p,z_p)$ 为中心进行缩放变换
   - 旋转变换
     - x、y、z点左边经旋转后的坐标。（y有差别）
     - 绕过原点的任意轴旋转（不懂）
     - void glRotate(Type angle, x , y , z) ，以angle为旋转角度，以从原点到指定（x,y,z）向量为旋转中心轴，逆时针旋转。
   - 错切变换
2. 齐次坐标与变换的矩阵表示
   - 为了将平移变换合并，使用齐次坐标系
   - 用n+1维向量表示n维向量
3. 变换模式
   - 图形软件包提供两种图形变换模式—— 图形模式和空间模式，从而可以方便地控制变换的次序
   - 图形模式
     - 矩阵的乘法不符合交换律
     - 每一次变换均可看成相对于**原始坐标系**中执行的，先调用的变换矩阵放在右边，后调用的矩阵放在左边。 固定坐标系模式
     - 个人理解：都是相对于初始坐标系进行变换
   - 空间模式
     - 又称**活动坐标系模式**。连续执行几个变换时，变换矩阵的合并方式和图形模式相反，即后调用的变换矩阵要乘在右边
     - 空间模式的特点是在连续执行几次变换时，每一次变换均可看成是**上一次变换所形成的新坐标系中进行的**。
     - 对变换后的坐标系进行变换

#### 裁剪

1. Sutherland-Cohen算法

   思想：

   - 判断直线是否完全在窗口内或窗口外


-  计算出直线段和窗口边界直线的一个交点，此交点把原线段分成两段，去掉显然在窗口外的一段，对另一段进行重新判断。

    实现：

-  用窗口的四条边把整个平面分成九个区域，对于窗口某一边界外侧的三个区域的四位编码中有一位全是1。
-  对线段两端进行编码，如果两端编码都是0000，则完全在窗口内；如果逻辑与不为0000，即某一位为1，表明两端点位于窗口同一条边界外侧，显然在窗口外。
   - 如果上述两条不能断定，就与分割线求交，抛弃完全在外侧的

2. Cyrus-Beck算法和梁友东-Barsky算法

   Cyrus---Beck算法基本思想

   **对于线段$P_1P_2$的参数方程表示，如果能判断出线段进入多边形时候的参数$t_s$和线段退出多边形时的参数$t_e$，则$t_st_e$之间的线段为裁剪完毕后的结果**。

   梁友栋---Barsky算法基本步骤

   上述终点组和起点组的特征分别表现为$r_k>0$和$r_k<0$，其中k对应于相应的裁剪边界(k=L、R、B、T,分别对应于左、右、下、上边界)沿    方向前进。

   $r_k>0$时，将进入k边界的外侧；$r_k<0$时，将进入k边界的内侧。若$r_k=0$时$s_k<0$,线段完全不可见，算法结束,否则就继续处理其他边。

   - 初始化线段在边界内的端点参数为ts=0、te=1。
   - 计算出各个裁剪边界的r、s值。
   - 当r=0且s<0时，舍弃该线段；否则计算线段与边界的交点参数t。
     - 当r<0时，参数t用于更新ts
     - 当r>0时，参数t用于更新te
   - 如果更新了ts或te后，使ts>te，则舍弃该线段。

3. 多边形剪裁

4. 字符剪裁

#### OpenGL中简单变换实例

## 第六章 三维空间的观察

#### 投影

把n维坐标系中的电变换成小于n维坐标系中的点。只讨论三维到二维的投影。

在三维空间中选择一个点作为视点，定义一个不经过视点的平面（投影平面），从视点向投影平面引出任意条射线（投影线）。穿过物体的投影线将与投影平面相交，在投影平面上形成物体的像，此像即为三维物体在二维投影平面上的投影。

投影变换分为透视投影和平行投影，区别是透视投影的投影中心和投影面之间的距离有限，而平行投影的投影中心和投影平面之间的距离是无限的

1. 透视投影

   - 投影中心和投影面之间的距离是有限的


- 透视投影的计算公式

2. 平行投影
   - 正投影：投影方向与投影平面法向相同。常见的正投影类型有：正视图、俯视图、侧视图、等轴测投影
   - 斜投影：常见斜投影类型：斜等测投影、斜二测投影
   - 平行投影的计算公式

3. 任意坐标系到观察坐标系中的变换
   - 灭点：一组不平行于投影平面的平行线，经过透视投影后相交于一点。灭点可以看作是三维空间的无穷远点在投影平面上的投影点。如果这组平行线平行与坐标轴，这时的灭点称为**主灭点**。

4. 射影变换

#### 视见体到规范视见体的变换

视见体中的内容要投影到投影平面上，然后显示在输出设备上的视口中。投影之前，三维空间中的物体要被三维视见体裁剪



1. 平行投影视见体的规范化
2. 透视投影视见体的规范化

#### 窗口到视口的变换

显示一幅图时，首先要在投影平面上定义一个窗口，同时还要在屏幕或绘图机上定义一个视口，窗口的内容要显示在视口中。

通常视见体的宽高比和视口的宽高比应该相同

#### 连续变换的处理



## 第七章 人机交互绘图技术

人机交互：用户与计算机系统之间的通信，它是**人与计算机之间各种符号和动作的双向信息交换**

#### 基本的图形输入设备和基本交互任务

1. 基本的图形输入设备
   - 定位设备
   - 笔画设备
   - 定值设备
   - 选择设备
   - 拾取设备
   - 字符串设备
2. 基本交互任务
   - 定位
   - 笔画
   - 定值
   - 选择
   - 拾取
   - 字符串

#### 人机交互输入模式（重点）

1. 请求模式

   请求模式下，输入设备的初始化是在应用程序中设置的，即只有输入设置命令（或语句）对**相应的设备设置**所需要的输入模式后，该设备才能作相应的输入处理。在这种请求的命令中要指定由哪一个应用程序调用及调用哪一个输入设备。

   在请求方式下，**程序和输入设备轮流处于工作状态和等待状态**，由程序支配输入设备的启动。

2. 样本模式

   把一台或多台输入设备定义为样本模式后，这些**设备会连续不断地把信息输入进来**，而不必等待应用程序的输入语句，即**信息的输入和应用程序中的输入命令无关**。当应用程序遇到**取样命令**时，就把**相应的物理设备的值作为取样数值**。

   优点：不像请求模式那样要求用户有一明显的动作，它对**连续的信息流输入比较方便**，也可同时处理多个输入设备的输入信息。

   缺点：当处理某一种输入的时间较长时，可能会失掉某些输入信息。程序和输入设备同时运行输入设备不断地产生数据，并把数据输入数据缓存区，从而不断刷新数据缓存区的内容。程序在运行时若遇到采样语句，就到数据缓存区中去取数据。这样，程序取的是**最新刷新的输入数据**。

3. 事件模式

   当设备设置成事件模式后，输入设备和程序并行工作。所有被**设置成事件方式的输入数据**（或事件）都被存放在一个**事件队列**中，该队列是以事件发生的时间排序的。

   用户在输入设备上完成一个输入动作（如按一下按钮等）便产生一个事件，输入信息及该设备编号等便存放到一个事件队列中。不同的应用程序可**到队列中来查询和提取与该应用程序有关的事件**。

   事件模式下的程序流程不同于样本模式，用户输入的信息是不会遗失。

4. 混合使用

   现代的计算机图形输入系统往往不是单一地使用一种输入方式，多种输入方式常常混合使用，即一个应用程序可以在集中输入控制方式下操作几种不同的设备输入器。

#### 常见辅助交互技术

1. 几何约束
2. 拖拽
3. 在三维视图上做三维输入


## 第八章 隐藏线和隐藏面的消除

计算机生成三维图形，首先确定三维场景中的物体哪些部分是可见的，生成三维图形时只绘制可见的部分。

三维场景中物体的可见性对透视投影是相对于投影中心，平行投影是相对于投影方向。

场景可见部分的判断过程称为可见线判断或可见面判定，也称为隐藏线消除或隐藏面消除。

两种基本算法：

1. 以**构成图像的每一个象素**为处理单元，对场景中所有表面，确定对于观察点是可见的表面，用该表面颜色填充该象素。**多用于面消隐**
2. 以**三维场景中的物体对象**为处理单元，在所有对象之间进行比较，除去完全不可见的物体和物体上不可见的部分。**多用于线消隐，也可用于面消隐**

#### 可见面判断的有效技术

可见面或可见线的判定是一个计算量很大的工作，如何减少可见面的判定非常重要。

1. 边界盒（*）

   在裁剪和消隐处理中，采用边界盒可避免不必要的裁剪运算，避免在物体或它们的投影之间进行不必要的计算。所谓物体的边界盒是指**<u>一个能够包含该物体的一个几何形状，该形状有较简单的边界</u>**

2. 后向面消除（*）

   把显然不可见的面去掉，从而减少消隐过程中的直线求交数目。

   **后向面**：表面的法向指向与观察者相背离的方向，这些多边形完全被多面体其他多边形遮挡。

   判断方法：设多边形F的顶点为 $v_1,v_2,…,v_L$ ，顶点的次序要求这样排列，使观察者在多边形外沿着$v_1 \rightarrow v_2 \rightarrow v_3 … \rightarrow v_L$ 走时，多边形的内部始终在他的右侧

   $sp  \ge 0$ 后向面

3. 非垂直投影转换成垂直投影

   判断两个多边形是否相交的方法之一是把它们投影到oxy平面上，然后判断它们的边界盒是否相交。投影到oxy，忽略了z坐标的顶点计算，大大减少计算量

   垂直投影比非垂直投影容易实现，并且计算量小。因此在进行消隐工作之前，首先应将非垂直投影转换成垂直投影，从而降低算法复杂性，提高运算速度

#### 多面体隐藏线消除算法（˚¬˚）

1. 算法基本思想

   预处理：

   - 使用后向面消除技术把多面体后向面去掉
   - 使用边界盒技术排除不相交的线段的求交运算

2. 确定边L和多边形E关系的技术

#### 基于窗口的子分算法

是一种分而治之的算法

整个屏幕可以称为窗口，窗口子分算法是一个**递归的四等分**过程，每一次把矩形的窗口等分成四个相等的小矩形，分成的矩形也可以称为窗口，每一次子分，均对要显示的**多边形和窗口**的关系作判断

存在关系：

1. 多边形包含了窗口
2. 多边形和窗口相交
3. 窗口包围了多边形
4. 窗口和多边形分离

处理方式：

1. 所有多边形均与窗口分离，这时只要把窗口所有的像素填上背景色
2. 只有一个多边形和窗口相交，或这个多边形包含在窗口内。先对窗口内的每一像素填上背景颜色，再对窗口内多边形用**扫面线算法填充**
3. 只有一个保卫窗口的多边形，则窗口用包围多边形的颜色填充
4. 如果有一个多边形盖在最上面，整个窗口填充为最上面的多边形颜色

#### 基于多边形的子分算法

用**多边形的边界**对区域进行划分，目的是尽量减少对区域划分的次数

#### Z缓冲器算法和扫描线算法

1. Z缓冲器算法

   z缓冲器算法是**最简单的隐藏面消除算法之一**。对屏幕上每一个像素点，找到此像素投影线与所有多边形交点中**离观察者最近的点**，此点的属性（颜色或灰度）值即为这一屏幕**像素点的属性值**。

   实现此算法需要两个缓冲器数组，即z缓冲器数组和帧缓冲器数组，$Zdepth[\ ][\ ]$与$Frame[\ ][\ ]$，算法如下

   1. 对屏幕上的每个点$(x,y)$，令Zdepth\[x][y]为z的极小值，Frame\[x][y]为背景颜色
   2. 对所有多边形做如下工作：对多边形上每一点(x,y)，计算其z值。若z>Zdepth\[x][y]，则Zdepth\[x][y]=z，并将此属性值赋给Frame\[x][y]，否则说明此点离观察者较远，两个数组的值都可以不用改变

   优点：简单、可靠，不需要对显示物体的面预先进行排序，有利于硬件实现

   缺点：需要额外的z缓冲器，将全屏幕的像素保存

2. 扫描线z缓冲器算法

   为了克服缺点，将整个屏幕平面划分为若干个区域。如果把整个区域取成屏幕上的一行，就得到了**扫面线z缓冲器算法**。z缓冲器的单元数和一条扫描线上的像素数目相同。从最上面的扫描线开始，向下对每一条扫面线进行处理。

   处理工作

   1. 把相应的帧缓冲器单元设置成**底色**，在**z缓冲器**中存放z的极小值。
   2. 对每个多边形检查它在oxy平面上的投影和当前的扫描线是否相交
      - 若不相交，则不考虑该多边形
      - 若相交，则扫描线和多边形边界的交点是成对出现的。
   3. 对**<u>每对交点中间的像素</u>**计算多边形所在平面对应点的深度（z值），并和z缓冲器中相对应单元存放间的深度值做比较。
      - 若前者大于后者，则z缓冲器的相应单元内容要被求得的平面深度代替，帧缓冲器相应单元的内容也要换成该平面的属性。
   4. 对所有的多边形都做上述处理后，帧缓冲器中这一行的值边反映了消隐后的图形。对帧缓冲器每一行都处理完后，就得到了整个消隐后的图形

   实现方式

   采用数据结构：一个多边形Y筒，一个边Y筒，一个多边形活化表盒一个边活化表。

   - 多边形Y筒和边Y筒各是一个记录，记录的**个数**和**扫描线的行数相同**。

   - 根据多边形顶点**y坐标最大值**来决定放入***多边形y筒***的行数

   - 根据边两端点的**较大y坐标值**来决定放入**边y筒**的相应行数

   - 多边形Y筒：
     - 多边形所在平面方程： $ax+by+cz+d=0$的系数     **a,b,c和d**
     - 和该多边形在$oxy$平面上的投影相交的扫描线的条数      $\Delta y =8$
     - 多边形的属性   **color**
     - 编号 **IP**

   - ![多边形Y筒](http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%A4%9A%E8%BE%B9%E5%BD%A2y%E7%AD%92.png)

   - 边Y筒
     - 边**上端点x坐标**的值
     - 在$oxy$平面上的投影和相邻两条扫面线的交点的**x坐标的差**$\Delta x$（斜率负倒数）
     - 边在oxy平面上的投影所覆盖的**扫面线条数** $\Delta y$
     - 边所属多边形的编号  **IP**

   - ![边y筒](http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E8%BE%B9y%E7%AD%92.png)

   - 多边形活化表，记录在$oxy$平面投影**和当前考虑的扫描线相交的多边形**

   - 边活化表，存放多边形的边和当前扫描线相交的边对。边对保存如下信息：
     - $x_l$	  左边的x坐标值
     - $\Delta x_l$   左边和两相邻扫描线交点的x坐标差
     - $\Delta y_l$   以左边的投影所覆盖的扫描线条数为初值，以后没处理一条扫描线-1
     - $x_r$      右边交点的x坐标值
     - $\Delta x_r$  右边和两相邻扫描线交点的x坐标差  
     - $\Delta y_r$   以右边的投影所覆盖的扫描线条数为初值，以后没处理一条扫描线-1
     - $z_l $       多边形平面在左交点处的深度值
     - $\Delta z_x$  沿扫描线向右走过一个像素时，多边形所在平面深度的增量
     - $ \Delta z_y $  沿y方向向下移过一根扫描线时，多边形所在平面深度的增量
     - IP      边所在多边形编号

   - 建立多边形Y筒和边Y筒，初始化多边形和边的活化表为空

   - 以**最上面的扫描线**为当前扫描线

   - 对当前扫描线y，把**帧缓冲器相应行置成底色**，**z缓冲器的各单元放z的极小值**

   - 检查多边形Y筒

     若有新的**多边形**涉及当前扫描线，则把它放入**多边形活化表**中。若有新的多边形加入多边形活化表，则要把该多边形在平面上的投影和**扫描线相交的边对**加入**边活化表**中。

   - **对边活化表中的每个边对**，令$Z_x = Z_l$，对每一个满足$x_l \le x \le x_r$ 的坐标为 $(x,y)$ 的像素从左到右依次进行处理。

     - 计算 $z_x = z_x + \Delta z_{x}$ 这就是对应像素所在平面的深度。如果比z缓冲器相应单元的值大，则要用它来替代原来的值，并把帧缓冲器相应单元内容改成多边形的属性

   - 若所有扫描线都已经处理完，则算法结束，否则选下一条扫描线为当前扫描线，转步骤3

   - 每条扫描线处理完后要做如下处理

     - 修改边活化表，对每一边做如下计算 $y_l = y_l -1 , y_r = y_r-1$ 。若$y_l$ 或$y_r$小于0，则相应边从活化表中去掉，并从边y筒找合适的边来替代。若这两条边同时结束于某一点，则去掉这一边对。

     - 若 y_l 和 y_r都不小于0，则修改 $x_r , x_l , z_l $为

       $x_r = x_r + \Delta x_r$  , $x_l = x_l + \Delta x_l$

       $z_l = z_l + \Delta z_x \Delta x_l + \Delta z_y$

     - 修改多边形活化表。令 $\Delta y = \Delta y -1$ ，若$\Delta y <0$ ，则将该多边形从多边形活化表中删除

#### 优先级排序表算法

按多边形离观察者的**远近**来建立一个多边形排序表，距离观察着**远的优先级低，近的优先级高**。

多边形排序表建立后，**从优先级低的多边形开始，依次把多边形的颜色填入帧缓冲存储器中**。

表中距观察者近的元素覆盖帧缓冲存储器中原有内容，当优先级最高的多边形送入缓冲器后，整幅图形就形成了。

算法：

1. 根据每个多边形顶点z坐标的极小值 $z_{min}$的大小，按由小到大对它们做初步排序，并把它们组成一个链表
2. 若链表中只有一个多边形，则结束算法，否则取表头多边形为P
3. 设Q为链表中P之外的任一多边形。若对所有Q都有$Qz_{min}>Pz_{min}$，则P不会遮挡其他多边形，为优先级最低的多边形，去除P，转2；否则，若所有Q都满足下面四项条件中的一项，则在链表中去除P，转2。若不满足此四项条件中任何一个的Q，交换P和Q转3。
   1. P 和Q在oxy平面上投影的边界盒在x或y方向上不相交
   2. P的各顶点均在Q的远离视点一侧
   3. Q的各顶点均在P的靠近视点一侧
   4. P和Q在oxy平面是的投影不相交

#### 光线投射算法

光学投射建立在几何光学的基础上，**沿光线的路径追踪可见面**，是一种有效的可见性判别技术。

具体做法：由视点出发穿过观察平面上一像素向场景发射一条射线，求出**射线与场景中各物体表面的交点**，离视点**最近的交点的颜**色即为像素要填的颜色。光线投射算法对于包含**曲面**，特别式包含**球面的场景**有很高的效率。

## 第九章 简单光照明模型

#### 简单光照明模型

光照模型是生成真实感图形的基础。用计算机在图形设备上生成连续色调的真实感图形必须完成四个基本的任务。第一，用数学方法建立所构造三维场景的几何描述，并将其输入计算机。第二，将三维几何转换为二维透视图。通过对场景的透视变换来完成。第三，确定场景中所有可见面。第四，计算场景中可见面的颜色。

1. 光源

   将光源称为**发光体**，反射表面称为**反射光源**

   光源可分为四类：点光源、线光源、面光源和体光源

2. 材质

   **材质本身有自己的颜色**。材质的颜色是**由它所反射的光的波长决定的**

   - 如果光线被投射至一个不透明的物体表面，则**部分光线被反射，部分被吸收**。
     - 物体表面的材质类型决定了反射光线的强弱。表面光滑较亮的材质将反射较多的入射光，而较暗的表面则吸收较多的入射光。  
   - 同样对于一个**半透明物体的表面，部分入射光会被反射，而另一部分则被折射**。

3. 简单光照明模型

   简单光照明模型只考虑被照明物体的几何形状对**反射和透射光的影响**，在简单光照模型中，环境假设为由白色照明，且反射光和透射光由用户选定

   1. 环境反射光

      环境反射光是由环境光在邻近物体上经过多次反射所产生的。

      亮度表示为： $I_a=k_aI_{pa}$，其中 $I_a$是物体的**环境反射光亮度**，$I_{pa}$为**环境光亮度**，$k_a$为**物体表面光反射系数**

   2. 漫反射光

      一个**比较粗糙**的，**无光照的物体表面对光的反射**表现为漫反射。

      郎伯定律指出：对于一个漫反射体，表面的反射光亮度和光源入射角的余弦成正比：$I_d =k_dI_{pd}\cos i$，其中$I_d$为物体表面漫反射光的光亮度，$I_{pd}$为光源垂直入射时反射光的光亮度，$i$为光源入射角，$k_d$为漫反射系数

      当观察漫反射物体时，人眼接受到光亮度和观察者的位置无关

      对漫反射物体，它的表面除受特定光源照射之外，还受到从环境来的反射光的照射

   3. 镜面反射光

      镜面反射光为朝一定方向的反射光。根据光的反射定律，反射光和入射光对称地分布于表面法向的两侧。

   4. 综和

      物体表面上任意一点射向视点的光亮度I应该为环境光、漫反射光和镜面反射光的总和。$k_a, k_d , k_s$分别表示环境反射，漫反射和镜面反射分量的比例系数，简单光照明模型为：

       $$I=k_aI_{pa}+k_dI_{pd}\cos i+k_sI_{ps}\cos ^n \theta$$

      当光源有多个时，则上式可写为$$I=k_aI_{pa}+\sum( k_dI_{pd}\cos i+k_sI_{ps}\cos ^n \theta)  $$

      其中$k_d+k_s=1$，该模型也称为Phong模型。Phong模型实际上是纯几何模型

#### 光滑明暗处理技术

通常的多边形扫描线算法来绘制这种近似表示的物体，**生成的图形将失去原有曲面的光滑性**，呈现多面体形状。

由于不同平面片之间不存在不连续的法向量，导致多个平面篇表示的物体表面光亮度呈现不连续跃变。

1. Gouraud明暗处理技术

   将曲面表面某一点的光亮度做近似表示，近似值为该曲面的各多边形顶点光亮度的**双线性插值**。

   步骤：

   线性插值

   在Gouraud明暗处理中，计算多边形顶点的光亮度可以通过简单光照明模型计算。

   **Gouraud明暗处理不能正确地模拟高光**，因为采用光亮度插值后将使多边形内的高光丢失

   **Gouraud明暗处理所绘制画面会诱发马赫带效应**，光亮度双线性插值保证了由多边形近似表示的曲面上各处光亮度的连续变化，但在相邻多边形的公共边界上光亮度的一阶导数并不连续，由于人眼光学错觉，光亮度变化一阶不连续的边界处会呈现亮带或黑带

2. Phong明暗处理技术

   法向量插值明暗处理。增加一定计算量客服了Gouraud明暗处理的缺点。

   基本思想：**对多边形顶点处法向量做双线性插值，在多边形内构造一个连续变化的法向量函数，依据函数计算多边形内各采用点的法向量带入光亮度计算公式**


## 第十章 Bezier曲线曲面

在计算机图形学中，常用的曲线曲面的类型有Bezier曲线曲面、B样条曲线曲面、孔斯曲面，这些曲线曲面采用分段和分片参数多项式的形式。曲线曲面的形状不依赖于坐标系的选择，**人机交互直观，易于计算，易于拼接，造型灵活等**

#### 曲线曲面的基础知识

1. 曲线的表示

   1. 显示表示

      对于一条曲线，一个坐标变量显示地表示为另一个变量的函数。在平面曲线的显示表示中，每一个x只对应一个y值，所以显示方程不能表示封闭或多值曲线，例如圆。

   2. 隐式表示

      平面曲线隐式表示的一半形式为$f(x,y)=0$。

      存在问题：1. 与坐标系相关 2.会出现斜率为无穷大的情况 3.非平面曲线难用常系数的非参数化函数表示 4.不利于计算和编程

   3. 参数表示

      将曲线上各点的坐标显示地表示成参数的函数形式，若去参数为t，曲线的参数表示为

      $$P(t) = (x(t),y(t),z(t)) , t \in [0,1]$$

      其中，$x(t),y(t)$和$z(t)$分别为t的显示函数，即每一个t对应空间一个点$(x(t),y(t),z(t))$

      在曲线曲面的表示上，参数表示比非参数表示具有更大的优越：

      - 参数方程形式不依赖于坐标系的选取，具有形状不变性
      - 在参数表示中，变化率以切实量来表示，不会出现无穷大的情况
      - 对参数表示的曲线、曲面进行平移、缩放和旋转等几何变换比较容易
      - 用参数表示的曲线曲面的交能力强，参数表示式中系数的几何意义明确，并提高了自由度，以便控制形状

2. 参数曲线的切矢量、弧长、法矢量和曲率

   1. 位置矢量

      曲线上任一点的位置矢量可表示为  $P(t) = (x(t),y(t),z(t)) , t \in [0,1]$

   2. 切矢量

   3. 弧长

   4. 曲率

   5. 主法矢量和副法矢量

#### Bezier曲线

Bezier曲线是一段n次多项式曲线，是构造**自由曲线曲面**的重要和基本方法之一。它有许多优点，如果保凸性，凸包性，曲线形状不依赖于坐标系选择，人机交互灵活

1. 曲线的定义

   在空间给定n+1个点$P_0,P_1,…,P_n$，称下列参数多项式曲线为n次Bezier曲线

   $$P(t)=\sum ^n_{i=0} P_iJ_{i,n}(t)$$

   其中$ J_{i,n}$是Bernstein基函数

    $$J_{i,n}(t)=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i} $$

   折现$P_0,P_1,…,P_n$称为P(t)的**控制多边形**，$P_0,P_1,…,P_n$个各点成为P(t)的**控制顶点**。控制多边形是对Bezier曲线P(t)的大致勾画，P(t)是对控制多边形的逼近。

2. 曲线的性质

   1. 非负性    $ J_{i,n}(t) \ge 0$
   2. 权性    $\sum ^n_{i=0} J_{i,n}(t) \equiv 1$
   3. 对称性   $J_{i,n}(t) = J_{n-i,n}(1-t) ,i=0,1,…,n$
   4. 导函数   
   5. 最大值
   6. 地推公式
   7. 升阶

   例子

3. Bezier曲线的性质

   1. 端点的位置

      Bezier曲线的起点为$P_0$，终点为$P_n$，即 $P(0) = P_0 , P(1)=P_n$

   2. 端点的切线

      Bezier曲线$P(t)$在起点$P_0$处与边 $\overline {P_0P_1}$相切，在终点P_n点处与边$\overline {P_{n-1}P_n}$相切，即 $P'(0) = n(P_1-P_0)，P'(1)=n(P_n-P_{n-1})$

   3. 端点的曲率 

   4. 仿射不变形

      Bezier曲线的形状和位置仅与它的控制顶点的位置有关，与仿射坐标系无关。

   5. 凸包性

      点集的凸包是指包含这些点的最小凸集。由于权性，对某个值t，点P(t)是各个控制顶点$P_i$的凸线性组合。

   6. 交互能力

      可以通过改变控制多边形的形状来改变$P(t)$的形状

   7. 变差缩减性

      平面内一直线与$P(t)$的交点个数不多于该直线与控制多边形的交点个数

   8. 保凸性

      如果控制多边形是个封闭的平面凸多边形，则Bezier曲线是一段凸的平面曲线

4. Bezier曲线性质进一步讨论


## 考试题型：

简答题（5个）

综合题（4个）

- 填充

- 变换

- 裁剪

- 投影

  强调联系的内容

计算题（2个）

